---
icon: pen-to-square
date: 2023-12-13
category:
  - interview
tag:
  - Java

star: true
sticky: true
---

# Java Interview Questions

## 1. Compare JDK vs. JVM vs. JRE

### JVM (Java Virtual Machine)

This is the heart of the Java Platform. It is a virtual machine that interprets Java bytecode and executes it as native code on the host machine. JVM is a part of the Java Runtime Environment.

### JRE (Java Runtime Environment)

JRE is the environment where Java programs run. This is the system that takes our Java code, and combines it with the necessary libraries, and starts the JVM to execute it. JRE is a part of the Java Development Kit

### JDK (Java Development Kit)

This is the tool necessary to compile, document, and package Java programs. It includes JRE.

## 2. Differences between C++ vs. Java

### C++

- Memory management is manual, developers are responsible for creating and destroying objects.
- Supports multiple inheritance.
- Supports pointers.
- Generates platform-dependent code (code that is written for a specific operating system. For example, a C++ program compiled on a Windows system cannot run on a Linux or Mac system without being recompiled on those systems).

## 3. Wrapper class

- Used to convert primitive data types into objects.
- Eight primitive types and their corresponding wrapper classes:
  - `byte` - `Byte`
  - `short` - `Short`
  - `int` - `Integer`
  - `long` - `Long`
  - `float` - `Float`
  - `double` - `Double`
  - `char` - `Character`
  - `boolean` - `Boolean`
- Useful when you want to use a primitive type in a data structure that requires objects.

## 4. String, StringBuffer, and StringBuilder

### String

- Immutable class, once a `String` object is created, it cannot be changed.
- If you try to alter their values, another object gets created.

### StringBuffer

- Mutable class, `StringBuffer` objects can be modified.
- It is thread-safe, meaning it is synchronized.

### StringBuilder

- Mutable class, `StringBuilder` objects can be modified.
- It is not thread-safe.
- Faster than `StringBuffer` because it is not synchronized.

## 5. Thread Safety and Synchronization

### Thread Safety:

- The property of an object that guarantees safe execution by multiple threads at the same time.

### Synchronization:

- A method to achieve thread safety in Java.
- Controls access by multiple threads to shared resources.
- Ensures that only one thread can access the resource at a time, preventing race conditions.

Example of a synchronized method in Java:

```java
public synchronized void add(int value){
    this.count += value;
}
```

## 6. Object Basics

### Class

- A blueprint or template for creating objects.
- Contains fields (variables) and methods to describe the behavior of an object.

### Object

- An instance of a class.
- Has state and behavior.
- The state is stored in fields, while methods display the object's behavior.

### State

- Created by the values assigned to the variables of an object.
- Example: A `Dog` class might have state variables like `color`, `name`, `breed`.

### Behavior

- Exposed through methods.
- Example: A `Dog` class might have methods like `bark()`, `eat()`, and `sleep()`.

## 7. toString method

- Used to get a string representation of an object.
- Defined in the `Object` class, can be overridden in any class.
- By default, returns a string that includes the name of the object's class and its hash code.
- Common to override `toString()` to provide a more meaningful string representation of your objects.

Example of overriding the `toString()` method:

```java
public class Dog {
    private String name;
    private String breed;

    @Override
    public String toString() {
        return "Dog{" +
               "name='" + name + '\'' +
               ", breed='" + breed + '\'' +
               '}';
    }
}

```

## 8. equals() and hashCode() methods in Java

### equals()

- Checks if two objects are equal.
- By default, checks for reference equality (it returns true if two references point to the same object).
- Can be overridden to check for logical equality based on the state of the objects.

### hashCode()

- Returns an integer value, generated by a hashing algorithm.
- Objects that are equal (according to their `equals()` method) should return the same hash code.
- Used in collections like `HashSet`, `HashMap`, etc., to find objects more efficiently.

**while equal objects must have equal hash codes, unequal objects can also have equal hash codes. It's a one-way relationship.**

Example of overriding these methods:

```java
public class Dog {
    private String name;
    private String breed;

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Dog dog = (Dog) obj;
        return Objects.equals(name, dog.name) &&
               Objects.equals(breed, dog.breed);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, breed);
    }
}
```

## 9. Inheritance, Method Overloading, and Method Overriding

### Inheritance

- a mechanism in which one class acquires the property of another class.
- in Java, classes can be derived from other classes, thereby inheriting fields and methods from those clases.

### Method Overloading

- a feature in Java that allows a class to have more than one method having the same name, if their argument lists are different.
- polymorphism
- the arugment list could differ in number of parameters, types of parameters, or both.

### Method Overriding

- a feature that allows a subclass to provide a specific implementation of a method that is already provided by its superclass.

## 10. Interface

- interfaces are used to achieve abstraction and multiple inheritance in Java.
- a class can implement any number of interfaces
- Interfaces are declared using the `interface` keyword.
- Classes implement interfaces using the `implements` keyword.
- All methods in an interface are implicitly public and abstract.
- All fields in an interface are implicitly public, static, and final.
- Prior to Java 8, interfaces could only contain method signatures(abstract methods) and constants(public static final variables). However, starting from Java 8, interfaces can contain default methods and static methods, both of which can have a body.

Example of an interface and a class that implements the interface:

```java
// Declare an interface
interface Animal {
    void eat();
}

// Implement the interface
class Dog implements Animal {
    public void eat() {
        System.out.println("Dog is eating");
    }
```

## 11. Abstract Class in Java

- A class that cannot be instantiated.
- Used to declare common characteristics of subclasses.
- Can have fields, constructors, and methods (including abstract methods).

### Key Points

- Abstract classes are declared using the `abstract` keyword.
- An abstract class can contain abstract methods â€” methods that are declared without an implementation.
- An abstract class can also contain non-abstract methods (methods with an implementation).
- You cannot create an instance of an abstract class. You can only create instances of its subclasses.

Example of an abstract class and a class that extends the abstract class:

```java
// Declare an abstract class
abstract class Animal {
    abstract void eat();

    void sleep() {
        System.out.println("Animal is sleeping");
    }
}

// Extend the abstract class
class Dog extends Animal {
    public void eat() {
        System.out.println("Dog is eating");
    }
}
```

## 12. Constructors - this() and super()

### this()

- Used to call a constructor from another constructor within the same class.
- Typically used when you have multiple constructors, and you want to call one constructor from another to avoid code duplication.

### super()

- Used to call the parent class's constructor from a child class.
- Typically the first statement in a subclass constructor.
- If you don't explicitly call a superclass constructor, Java will automatically insert a call to the no-argument constructor of the superclass.

Example of using `this()` and `super()`:

```java
public class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }
}

public class Dog extends Animal {
    String breed;

    Dog(String name, String breed) {
        super(name); // Call the superclass constructor
        this.breed = breed;
    }

    Dog(String breed) {
        this("Unknown", breed); // Call the other constructor in this class
    }
}
```

## 13. Polymorphism and instanceof

### Polymorphism

- a fundamental concept in Object-Oriented Programming.
- it describes a class's ability to take on many forms.
- most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class obect.
  - For example, consider an Animal class and a Dog class that extends Animal. If we define a method in Animal, we can use it in Dog as well, but it can perform different actions based on the object type.

### instanceof

- the `instanceof` keyword is a binary operator used to test if an object(instance) is a subtype of a given type.
- It's usually used for type checking and to avoid `ClassCastException` at runtime.

```java
public class Animal {
    void eat() {
        System.out.println("Animal is eating...");
    }
}

public class Dog extends Animal {
    @Override
    void eat() {
        System.out.println("Dog is eating...");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.eat(); // Outputs "Dog is eating..."

        if (myAnimal instanceof Dog) {
            System.out.println("myAnimal is an instance of Dog");
        }
    }
}
```

## 14. What is Coupling

- coupling refers to the degree to which one class knows about another class. If one class uses the methods of another class, there is coupling between these classes.
- there are 2 types of coupling: 1. loose coupling 2. tight coupling

### loose coupling

- in loose coupling, classes are indepdent of each other. This means changing something major in one class doesn't affect the other.
- loose coupling is a desirable characteristic for maintable coude because it allows you to change parts of your code withouting affecting unrelated parts.

### tight coupling

- in tight coupling, classes are highly dependent on each other. This means changing something major in one class may affect the other.

#### example of tight coupling

```java
package tightcoupling;

public class Edureka {
      public static void main(String args[]) {
           A a = new A();
           a.display();
      }
}

class A {
      B b;
      public A() {
            b = new B();
      }
      public void display() {
            System.out.println("A");
            b.display();
      }
}

class B {
       public B() {
       }
       public void display() {
             System.out.println("B");
        }
}
```

#### example of loose coupling

```java
package loosecoupling;

import java.io.IOException;

public class Edureka {
      public static void main(String args[]) throws IOException {
           Show b = new B();
           Show c = new C();
           A a = new A(b);
           a.display();
           A a1 = new A(c);
           a1.display();
      }
}

interface Show {
      public void display();
}

class A {
      Show s;
      public A(Show s) {
           this.s = s;
      }
      public void display() {
           System.out.println("A");
           s.display();
       }
}

class B implements Show {
       public B() {
       }
       public void display() {
            System.out.println("B");
       }
}

class C implements Show {
       public C() {
       }
       public void display() {
            System.out.println("C");
       }
}
```

In object-oriented design, the goal is to make the system loosely coupled, and the interfaces are a good way to achieve this. When classes communicate through interfaces, we can change the concrete implementation without affecting the classes that use the interface.

## 15. What is cohesion?

- Refers to how closely all the routines in a class or all the code in a routine support a central purpose.
- High cohesion is associated with several desirable traits of software including robustness, reliability, reusability, and understandability.
- Low cohesion is associated with undesirable traits such as being difficult to maintain, test, reuse, or even understand.
- Highly cohesive classes are often easier to maintain and less error-prone, because they have a single, well-defined role.

Example of high cohesion in Java:

```java
public class User {
    private String name;
    private String email;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public void changeEmail(String newEmail) {
        // Validate the new email
        // Update the email
    }
}
```

## 16. What is encapsulation?

Encapsulation refers to the bundling of data(fields) and methods that act on that data into a single unit, which is typically a class in Java.

### Encapsulation provides the following benefits

- `Control over data`: By encapsulating the datam we can control what parts of the data can be accessed and how it can be manipulated. This is done by using access modifiers (`public`, `private`, `protected`) to restrict access to the fields of a class.
- `Data Hiding`: encapsulation hides the internal states of the objects and only exposes the methods and properties that users need to interact with.
- `Code Maintainability`: encapsulation makes the code more maintainable because we can change one part of the code without affecting other parts.

```java
public class User {
    private String name; // Private field, can't be accessed directly from outside the class

    // Public getter method to access the private field
    public String getName() {
        return name;
    }

    // Public setter method to modify the private field
    public void setName(String name) {
        this.name = name;
    }
}
```

In this example, the `name` field is encapsulated in the `User` class. It's marked as `private`, so it can't be accessed directly from outside the class.

## 17. Inner class and Static Inner class?

- In Java, a class can be defined within another class, such classes are known as nested classes.
- There are two types of nested classes: non-static (inner class) and static

### Inner class:

- non-static nested class
- it has access to all of the variables and methods of its outer class and can refer to them directly in the same way that other non-static members of the outer class do.

## Static Nested Class:

- static class at the member level
- it can be instantiated without an object of the outer class, so it can't access non-static variables and methods of the outer class.

Example of an inner class and a static nested class in Java:

```java
public class OuterClass {
    private String msg = "Outer";

    // Inner class
    class InnerClass {
        void display() {
            System.out.println(msg); // Can access outer class's instance variable
        }
    }

    // Static nested class
    static class StaticNestedClass {
        void display() {
            // System.out.println(msg); // Can't access outer class's instance variable
        }
    }
}
```

## 18. What is an anonymous class?

- A class without a name that is declared and instantiated in a single statement.
- Typically used when you need to use a local class only once, while creating an instance of an interface or a class.
- Often used in graphical programming and working with event listeners, as well as in implementations of functional interfaces in Java 8.

Example of an anonymous class in Java:

```java
interface HelloWorld {
    void greet();
}

class Main {
    public static void main(String[] args) {
        // Create an anonymous class that implements HelloWorld
        HelloWorld helloWorld = new HelloWorld() {
            public void greet() {
                System.out.println("Hello, world!");
            }
        };

        helloWorld.greet(); // Outputs "Hello, world!"
    }
}
```

## 19. Access Modifiers - public, private, protected, and default

- **Public:** Visible to all classes everywhere, whether they are in the same package or have a different package.
- **Private:** Only accessible within the declared class.
- **Protected:** Accessible in the same package and also in the subclass of different packages.
- **Default (Package-Private):** Accessible only within the same package.

| Modifier    | Class | Package | Subclass | World |
| ----------- | ----- | ------- | -------- | ----- |
| public      | Y     | Y       | Y        | Y     |
| protected   | Y     | Y       | Y        | N     |
| no modifier | Y     | Y       | N        | N     |
| private     | Y     | N       | N        | N     |

(Y = accessible, N = not accessible)

## 20. Final Method, Variable, and Class

- **Final Variable:** Once assigned, it always contains the same value.
- **Final Method:** Can't be overridden in a subclass.
- **Final Class:** Can't be extended by other classes.

Example of a final variable, method, and class in Java:

```java
final class FinalClass { // Final class
    final int finalVariable = 10; // Final variable

    final void finalMethod() { // Final method
        System.out.println("This is a final method.");
    }
}
```

## 21. Static variables and methods

In Java, the `static` keyword is used to create variables and methods that belong to the class, rather than to the instance of the class.

### Static Variable:

- A static variable is common to all the instances (or objects) of the class because it is a class-level variable.
- It is not tied to a specific object instance of the class.
- we can access the static variable without creating an instance of the class

### Static Method:

- It belongs to the class rather than the object of a class.
- A static method can be invoked without the need for creating an instance of a class.
- Static methods can access static variables and can change the value of it.

```java
public class App {
    static int staticVariable;

    // Static method
    static void staticMethod() {
        staticVariable = 20;
        System.out.println("This is a static method.");
        System.out.println("Static variable is " + staticVariable);
    }

    public static void main(String[] args) {
        // Access static variable without creating an instance
        App.staticVariable = 10;

        // Call static method without creating an instance
        App.staticMethod();
    }
}
```

## 22. more will be coming today:)
