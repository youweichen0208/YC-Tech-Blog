import{_ as n,o as a,c as s,e}from"./app-dqUG1HtW.js";const t={},i=e(`<h1 id="backtracking" tabindex="-1"><a class="header-anchor" href="#backtracking" aria-hidden="true">#</a> Backtracking</h1><h2 id="_1-what-exactly-is-backtracking" tabindex="-1"><a class="header-anchor" href="#_1-what-exactly-is-backtracking" aria-hidden="true">#</a> 1. What exactly is backtracking</h2><p>Backtracking is an optimization that involves abandoning a &quot;path&quot; once it is determined that the path cannot lead to a solution. The idea is similar to binary search trees - if we are looking for a value x, and the root node has a value greater than x, then we know we can ignore the entire right subtree.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>To summarize the difference between exhaustive search and backtracking:

In an exhaustive search, we generate all possibilities and then check them for solutions. In backtracking, we prune paths that cannot lead to a solution, generating far fewer possibilities.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-backtracking-code-template" tabindex="-1"><a class="header-anchor" href="#_2-backtracking-code-template" aria-hidden="true">#</a> 2. Backtracking code template:</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// let curr represent the thing you are building
// it could be an array or a combination of variables

function backtrack(curr){
    if (base case) {
        Increment or add to answer
        return;
    }

    for (iterate over input) {
        Modify curr
        backtrack(curr)
        Undo modification to curr
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-example-leetcode-46" tabindex="-1"><a class="header-anchor" href="#_3-example-leetcode-46" aria-hidden="true">#</a> 3. Example: Leetcode 46</h2><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p><h5 id="example-1" tabindex="-1"><a class="header-anchor" href="#example-1" aria-hidden="true">#</a> Example 1:</h5><p>Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><h5 id="example-2" tabindex="-1"><a class="header-anchor" href="#example-2" aria-hidden="true">#</a> Example 2:</h5><p>Input: nums = [0,1] Output: [[0,1],[1,0]]</p><h5 id="example-3" tabindex="-1"><a class="header-anchor" href="#example-3" aria-hidden="true">#</a> Example 3:</h5><p>Input: nums = [1] Output: [[1]]</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">backtracking</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> list<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> ans<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> curr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> input<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> input<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">:</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>curr<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                curr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">backtracking</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>
                curr<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="time-complexity-of-this-code-is-o-n-n-where-n-is-the-length-of-the-input-array" tabindex="-1"><a class="header-anchor" href="#time-complexity-of-this-code-is-o-n-n-where-n-is-the-length-of-the-input-array" aria-hidden="true">#</a> Time complexity of this code is O(n*n!), where n is the length of the input array:</h5><ul><li>There are n! permutations of the array</li><li>For each permutation, the code makes a deep copy of the current permutation and adds it to the result list. This operation takes O(n) time.</li><li>Therefore, the total time complexity is O(n*n!)</li></ul><h5 id="the-space-complexity-of-this-code-is-o-n" tabindex="-1"><a class="header-anchor" href="#the-space-complexity-of-this-code-is-o-n" aria-hidden="true">#</a> The space complexity of this code is O(n)</h5><p>the maximum depth of the recursion (the maximum length of the <code>curr</code> list). This is because the code uses recursion to generate permutations, and each recursive call adds a new element to the <code>curr</code> list.</p><h2 id="_4-when-should-we-use-backtracking" tabindex="-1"><a class="header-anchor" href="#_4-when-should-we-use-backtracking" aria-hidden="true">#</a> 4. When should we use backtracking?</h2><ul><li>Permutations and Combinations: If we need to generate all permutations or combinations of a set of items, we can use backtracking to build each possibility one item at a time, and abandon a partial permutation or combination as soon as we know it can&#39;t be extended to a valid one.</li><li>Path Finding: In problems where we need to find a path from one pointer to another, such as in a maze or a graph, backtracking can be used to incrementally build paths, and abandon a path as soon as we know it doesn&#39;t lead to the destination.</li><li>Subset Sum and Partitioning Problems: Backtracking can be used to find subsets of items that meet certain criteria, like a subset of numbers that adds up to a particular sum.</li></ul><h2 id="lessons-learned-from-backtracking" tabindex="-1"><a class="header-anchor" href="#lessons-learned-from-backtracking" aria-hidden="true">#</a> Lessons learned from backtracking</h2><ol><li>In backtracking, we start from a certain point, and then explore all possible paths from there. Once the path is explored, we &quot;undo&quot; it and explore other paths.</li><li>Even if a branch can lead to a solution, backtracking will still &quot;undo&quot; or backtrack after exploring that branch. This is because there might be other solutions that can be found by different choices at some point in the branch.</li><li>&quot;Undoing&quot; doesn&#39;t mean reversing the order of the path. It means going back to a previous state and making a different choice to explore a different path.</li><li>Use DFS when we need to visit every node in a graph, and use backtracking when we need to find a sequence of choices that satisfies a set of constraints.</li></ol>`,23),c=[i];function o(p,l){return a(),s("div",null,c)}const r=n(t,[["render",o],["__file","backtracking.html.vue"]]);export{r as default};
