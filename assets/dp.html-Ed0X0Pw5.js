const e=JSON.parse('{"key":"v-297ece07","path":"/data-structure/dp.html","title":"Dynamic Programming","lang":"en-US","frontmatter":{"icon":"pen-to-square","author":"Youwei Chen","date":"2023-12-10T00:00:00.000Z","category":["data structure"],"tag":["Java","Algorithm","Dynamic Programming"],"description":"Dynamic Programming 1. What exactly is DP? In short, dynamic programming is optimized recursion. The arguments that a recursive function takes represents a state. When we looked at tree problems, we never visited a node more than once in our DFS, which means that a state can be repeated, usually an exponential number of times. To avoid repeating computation, we use something called memoization. When we find the answer (the return value) for a given state, we cache that value(usually in hashmap). Then in the future, if we ever see the same state again, we can just refer to the cached value without the needing to re-calculate it.","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/data-structure/dp.html"}],["meta",{"property":"og:site_name","content":"YC Tech Blog"}],["meta",{"property":"og:title","content":"Dynamic Programming"}],["meta",{"property":"og:description","content":"Dynamic Programming 1. What exactly is DP? In short, dynamic programming is optimized recursion. The arguments that a recursive function takes represents a state. When we looked at tree problems, we never visited a node more than once in our DFS, which means that a state can be repeated, usually an exponential number of times. To avoid repeating computation, we use something called memoization. When we find the answer (the return value) for a given state, we cache that value(usually in hashmap). Then in the future, if we ever see the same state again, we can just refer to the cached value without the needing to re-calculate it."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-12-11T19:36:16.000Z"}],["meta",{"property":"article:author","content":"Youwei Chen"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Algorithm"}],["meta",{"property":"article:tag","content":"Dynamic Programming"}],["meta",{"property":"article:published_time","content":"2023-12-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-11T19:36:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dynamic Programming\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-10T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-11T19:36:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Youwei Chen\\"}]}"]]},"headers":[{"level":3,"title":"1. What exactly is DP?","slug":"_1-what-exactly-is-dp","link":"#_1-what-exactly-is-dp","children":[]},{"level":3,"title":"2. Top-down vs. bottom-up","slug":"_2-top-down-vs-bottom-up","link":"#_2-top-down-vs-bottom-up","children":[]},{"level":3,"title":"3. When should I consider using DP?","slug":"_3-when-should-i-consider-using-dp","link":"#_3-when-should-i-consider-using-dp","children":[]},{"level":3,"title":"4. Framework for DP:","slug":"_4-framework-for-dp","link":"#_4-framework-for-dp","children":[]}],"git":{"createdTime":1702323376000,"updatedTime":1702323376000,"contributors":[{"name":"youweichen0208","email":"youweichen0208@gmail.com","commits":1}]},"readingTime":{"minutes":1.16,"words":349},"filePathRelative":"data-structure/dp.md","localizedDate":"December 10, 2023","excerpt":"<h1> Dynamic Programming</h1>\\n<h3> 1. What exactly is DP?</h3>\\n<p>In short, dynamic programming is optimized recursion. The arguments that a recursive function takes represents a state. When we looked at tree problems, we never visited a node more than once in our DFS, which means that a state can be repeated, usually an exponential number of times. To avoid repeating computation, we use something called memoization. When we find the answer (the return value) for a given state, we cache that value(usually in hashmap). Then in the future, if we ever see the same state again, we can just refer to the cached value without the needing to re-calculate it.</p>","autoDesc":true}');export{e as data};
