import{_ as s,o as a,c as e,e as t}from"./app-oqUKl6-m.js";const n="/assets/images/graph1.jpg",p="/assets/images/graph2.jpg",o={},c=t('<h1 id="graphs" tabindex="-1"><a class="header-anchor" href="#graphs" aria-hidden="true">#</a> Graphs</h1><h2 id="what-is-graphs" tabindex="-1"><a class="header-anchor" href="#what-is-graphs" aria-hidden="true">#</a> What is graphs?</h2><p>A graph is any collection of nodes and connections between those nodes. Another term for nodes is <code>vertices</code>, and the connections between the nodes are called <code>edges</code>. One of the difference between trees and graphs is that the trees cannot contain any cycles.</p><h2 id="first-graph-input-format-array-of-edges" tabindex="-1"><a class="header-anchor" href="#first-graph-input-format-array-of-edges" aria-hidden="true">#</a> First graph input format: array of edges</h2><p>In this input format, the input will be a 2D array. Each element of the array will be in the form <code>[x,y]</code>, which indicates that there is an edge between <code>x</code> and <code>y</code>.</p><figure><img src="'+n+`" alt="Graph example" tabindex="0" loading="lazy"><figcaption>Graph example</figcaption></figure><p>This example graph can be represented by an array of directed edges: <code>edges = [[0, 1], [1, 2], [2, 0], [2, 3]]</code>.</p><p>However, <strong>At every node, we would need to iterate over the entire input to find the neighbors.</strong> This is very slow!</p><p>Before starting the traversal, we can pre-process the input so that we can easily find all neighbors of any given <code>node</code>. Ideally, we want a data structure where we can give <code>node</code> as an argument and be returned a list of neighbors. The easiest way to accomplish this is using a hashmap.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">buildGraph</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge<span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            graph<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        graph<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// if (!graph.containsKey(y)) {</span>
        <span class="token comment">//     graph.put(y, new ArrayList&lt;&gt;());</span>
        <span class="token comment">// }</span>
        <span class="token comment">// graph.get(y).add(x);</span>

        <span class="token comment">// uncomment the above lines if the graph is undirected</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> graph<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="second-graph-input-format-adjacency-list" tabindex="-1"><a class="header-anchor" href="#second-graph-input-format-adjacency-list" aria-hidden="true">#</a> Second graph input format: adjacency list</h2><p>In an adjacency list, the nodes will be numbered from <code>0</code> to <code>n - 1</code>. The input will be a 2D integer array, let&#39;s call it <code>graph</code>. <code>graph[i]</code> will be a list of all the outgoing edges from the ith node.</p><figure><img src="`+n+'" alt="Graph example" tabindex="0" loading="lazy"><figcaption>Graph example</figcaption></figure><p>The graph in the image above can be represented by the adjacency list <code>graph = [[1], [2], [0, 3], []]</code>.</p><h2 id="third-graph-input-format-adjacency-matrix" tabindex="-1"><a class="header-anchor" href="#third-graph-input-format-adjacency-matrix" aria-hidden="true">#</a> Third graph input format: adjacency matrix</h2><p>The next format is an adjacency matrix. Once again, the nodes will be numbered from <code>0</code> to <code>n - 1</code>. We will be given a 2D matrix of size <code>n*n</code>, let&#39;s call it <code>graph</code>. If <code>graph[i][j] == 1</code>, that means there is an outgoing edge from node <code>i</code> to node <code>j</code>.</p><figure><img src="'+p+`" alt="Graph Example" tabindex="0" loading="lazy"><figcaption>Graph Example</figcaption></figure><h2 id="graphs-dfs" tabindex="-1"><a class="header-anchor" href="#graphs-dfs" aria-hidden="true">#</a> Graphs - DFS</h2><h3 id="graph-dfs-code-template" tabindex="-1"><a class="header-anchor" href="#graph-dfs-code-template" aria-hidden="true">#</a> Graph: DFS code template</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">START_NODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token constant">START_NODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// do some logic</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> neighbor<span class="token operator">:</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>seen<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>To avoid cycles with undirected graphs, we need to use a set <code>seen</code> to track which nodes we have already visited. After performing a DFS on a connected component, all nodes in that component will be inside <code>seen</code> (because the DFS will visit every node in the component).</li><li><strong>DFS traversal</strong>: while the <code>stack</code> is not empty, the algorithm keeps popping nodes from the <code>stack</code>, perform some logic, and then pushes all unseen neighbors of the current node to the <code>stack</code>.</li><li><strong>Return the result:</strong> After the DFS traversal is complete, the function returns <code>ans</code>, which holds the result of the logic performed during the travsersal.</li></ul><h3 id="time-complexity" tabindex="-1"><a class="header-anchor" href="#time-complexity" aria-hidden="true">#</a> Time complexity:</h3><p>The time complexity for DFS on graphs is O(n+e), where n is the number of nodes and e is the number of <strong>edges</strong>.</p><ul><li><p><strong>Visiting each node</strong>: DFS starts at a certain node and explores as far as possible along each branch before backtracking. This means that every node in the graph will be visited exactly once, contributing O(n) to the time complexity.</p></li><li><p><strong>Exploring each edge</strong>: For each node, the algorithm checks all its adjacent nodes. In other words, it explores every edge that is connected to the node. Since each edge in the graph will be looked at exactly once, this contributes O(e) to the time complexity.</p></li></ul><h3 id="space-complexity" tabindex="-1"><a class="header-anchor" href="#space-complexity" aria-hidden="true">#</a> Space Complexity:</h3><p>When we build <code>graph</code>, we are storing all the edges in arrays. Therefore the space complexity is O(n+e)</p><h2 id="graphs-bfs" tabindex="-1"><a class="header-anchor" href="#graphs-bfs" aria-hidden="true">#</a> Graphs - BFS</h2><p>In graphs, it is mostly the case when we are asked to find the <strong>shortest path</strong>.</p><h3 id="graph-bfs" tabindex="-1"><a class="header-anchor" href="#graph-bfs" aria-hidden="true">#</a> Graph: BFS</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token constant">START_NODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token constant">START_NODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// do some logic</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> neighbor<span class="token operator">:</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>seen<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>With an efficient queue, BFS has the same time and space complexity as DFS.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,31),i=[c];function l(u,r){return a(),e("div",null,i)}const k=s(o,[["render",l],["__file","graphs.html.vue"]]);export{k as default};
