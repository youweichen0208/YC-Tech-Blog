import{_ as e,o as i,c as a,e as t}from"./app-tSsWOM-C.js";const o="/assets/images/simplified-ddd-image.png",n={},s=t('<h2 id="cqrs-command-query-responsibility-segregation" tabindex="-1"><a class="header-anchor" href="#cqrs-command-query-responsibility-segregation" aria-hidden="true">#</a> CQRS(command query responsibility segregation)</h2><p>The fundamental idea is that we should divide an object&#39;s methods into two sharply separated categories:</p><ol><li><code>Queries</code>: return a result and do not change the observable state of the system(are free of side effects).</li><li><code>Commands</code>: change the state of a system but do not return a value.</li></ol><h3 id="why-separating-methods-that-change-state-modifiers-commands-from-those-that-don-t-queries-is-so-valuable-in-practice" tabindex="-1"><a class="header-anchor" href="#why-separating-methods-that-change-state-modifiers-commands-from-those-that-don-t-queries-is-so-valuable-in-practice" aria-hidden="true">#</a> why separating methods that change state (modifiers/commands) from those that don&#39;t (queries) is so valuable in practice:</h3><ol><li><code>Predictability and Debugging</code>:</li></ol><ul><li>Query methods are &quot;safe&quot; - we can call them multiple times or in any order without side effects.</li><li>If something goes wrong, we know how to focus on the modifier methods first, since queries can&#39;t be the cause of state-related bugs.</li></ul><ol start="2"><li><code>Testing and Maintenance</code>:</li></ol><ul><li>Queries are easier to test since we just need to verify return values.</li><li>Modifiers require testing state changes and potential side effects.</li></ul><ol start="3"><li><code>Parallelization and Caching</code>:</li></ol><ul><li>Query results can be safely cached.</li><li>Multiple queries can run in parallel without lock coordination.</li><li>Modifiers need careful synchronization to avoid race conditions.</li></ul><ol start="4"><li><code>Database Separation</code>: <ol><li>Commands(Modifiers) on the Main Database: <ul><li>Modifiers are responsible for changing the state of the system, such as creating, updating, or deleting records in the database. Since these operations can affect the integrity and consistency of the data, they need to be directed to the main database where the data is authoritative and can be modified.</li><li>By ensuring that <code>commands</code> always go to the master database, we can maintain consistency and ensure the state is updated correctly. Thisalso allows proper handling of transactions, which is often required for modifying data.</li></ul></li><li>Queries on Read Replicas: <ul><li><code>Queries</code> on the other hand <code>only read data</code> without modifying it. These operations can be safely executed on read replicas because they don&#39;t change the data&#39;s state. Since replicas are usually eventually consistent, they can serve read requests without the risk of disrupting data consistency.</li><li>Using replcias for queries offloads work from the main database, allowing it to focus on write-heavy operations. This improves <code>performance</code>, <code>scalability</code>, and <code>availability</code>.</li></ul></li><li>Consistency and Data Integrity: <ul><li>When <code>modifiers</code> are directed to the <code>main database</code>, we ensure that write operations are consistent and properly synchronized, and that <code>transactional integrity</code> is maintained.</li><li>On the other hand, queries are less critical in terms of consistency, since they do not affect the data, and read replicas can serve slightly outdated data, without compromising overall system reliability.</li></ul></li></ol></li></ol><h2 id="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice" tabindex="-1"><a class="header-anchor" href="#applying-simplified-cqrs-and-ddd-patterns-in-a-microservice" aria-hidden="true">#</a> Applying simplified CQRS and DDD patterns in a microservice</h2><p>The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer. Each layer has its own data model. Each layer has its own data model(note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies. More importantly, the two layers can be within the same tier or microservice. Or they can be optimized and scaled out separately without affecting one another.</p><figure><img src="'+o+'" alt="Simplified CQRS and DDD microservice" tabindex="0" loading="lazy"><figcaption>Simplified CQRS and DDD microservice</figcaption></figure><p>The important design aspect here is that the microservice has split the queries and ViewModels(data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</p><h2 id="design-a-ddd-oriented-microservice" tabindex="-1"><a class="header-anchor" href="#design-a-ddd-oriented-microservice" aria-hidden="true">#</a> Design a DDD-oriented microservice</h2><p>DDD descibes independent problem areas as Bounded Contexts(each Bounded Context correlates to a microservice). Where to draw the boundaries is the key task when designing and refining a microservice. DDD patterns help us understand the complexity in the domain. For the domain model for each Bounded Context, we identify and define the entities, value objects, and aggregates that model our domain. We build a domain model that is contained within a boundary that defines our context.</p><p>Determing where to place boundaries between Bounded Contexts balances two competing goals. Our services should handle all responsibilities related to our domain internally. But we should also ensure that communication between different bounded contexts is kept to a minimum. Too many cross-service communication introduces <code>complexity</code>, <code>latency</code>, and <code>failture risks</code>.</p><p><a href="/assets/images/domain-driven-design-microservice.png">Layers in a Domain-Driven Design Microservice</a></p><p>Each layer is a VS project. Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</p><h2 id="design-a-microservice-domain-model" tabindex="-1"><a class="header-anchor" href="#design-a-microservice-domain-model" aria-hidden="true">#</a> Design a microservice domain model</h2>',21),r=[s];function d(c,l){return i(),a("div",null,r)}const m=e(n,[["render",d],["__file","ddd.html.vue"]]);export{m as default};
